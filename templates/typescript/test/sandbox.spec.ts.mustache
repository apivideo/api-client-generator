import { expect } from 'chai';
import ApiVideoClient from '../src';

{{#models}}
{{#model}}
import {{classFilename}} from '../{{ modelPackage }}/{{classFilename}}';
{{/model}}
{{/models}}

{{# apiInfo.apis }}
{{^x-client-hidden}}
import {{classFilename}} from '../{{ apiPackage }}/{{classFilename}}';
{{/x-client-hidden}}
{{/ apiInfo.apis }}

const timeout = (ms = 100) => new Promise((resolve) => {
  setTimeout(() => {
    resolve();
  }, ms);
});

(async () => {
  try {
    if (!process.env.API_KEY) {
      console.error('You must provide `API_KEY` environment variable to test the sandbox.');
      console.log('API_KEY=xxx yarn test:sandbox');

      process.exit(1);
    }

    // Create client for Sandbox and authenticate
    const client = new ApiVideoClient({ apiKey: process.env.API_KEY });

    // Create
    const videoTitle = 'Course #4 - Part B';
    const { videoId, title } = await client.videos.create({ title: videoTitle });

    // upload a video resource
    await client.videos.upload(videoId,'test/data/small.webm').then((video) => {
      expect(title).to.equals(videoTitle);
    });

    // Update video properties
    const newDescription = 'Course #4 - Part C';
    await client.videos.update(videoId, { description: newDescription }).then((video) => {
      expect(video.description).to.equals(newDescription);
    });

    // Search videos with paginated results
    await client.videos.list({ currentPage: 1, pageSize: 50 }).then(({ data: videos }) => {
      expect(videos).to.be.an('array');
      videos.forEach(video => expect(video).to.have.keys(new Video()));
    });

    // Upload a video thumbnail
    await client.videos.uploadThumbnail(videoId, 'test/data/test.jpg').then((video) => {
      expect(video.videoId).to.equals(videoId);
    });

    // Pick a thumbnail from the given time code.
    await client.videos.pickThumbnail(videoId, { timecode: '00:15:22.05' }).then((video) => {
      expect(video.videoId).to.equals(videoId);
    });

    // Upload video subtitle
    await client.captions.upload(videoId, 'en', 'test/data/en.vtt').then((subtitle) => {
      expect(subtitle).to.have.keys(new Subtitle());
    });

    await timeout(1000);

    // Get video subtitle by language
    await client.captions.get(videoId, 'en').then((subtitle) => {
      expect(subtitle.src).to.be.a('string');
    });

    // Update the default caption language
    await client.captions.update(videoId, 'en', { _default: true }).then((subtitle) => {
        expect(subtitle.srclang).to.equals('en');
        expect(subtitle._default).to.equals(true);
    });

    // Delete caption by language
    await client.captions.delete(videoId, 'en').then((statusCode) => {
      expect(statusCode).to.equals(204);
    });

    // Upload video chapter
    await client.chapters.upload(videoId, 'en', 'test/data/en.vtt').then((chapter) => {
      expect(chapter.language).to.equals('en');
    });

    await timeout(1000);

    // Get video chapter by language
    await client.chapters.get(videoId, 'en').then((chapter) => {
      expect(chapter.language).to.equals('en');
    });

    // Delete chapter by language
    await client.chapters.delete(videoId, 'en').then((statusCode) => {
      expect(statusCode).to.equals(204);
    });

    // // Get video Analytics Data for the current year
    // await client.analyticsVideo.get(videoId, new Date().getFullYear()).then((analyticVideo) => {
    //   expect(analyticVideo.data).to.be.an('array');
    // });

    // Delete video ressource
    await client.videos.delete(videoId).then((statusCode) => {
      expect(statusCode).to.equals(204);
    });

    // Create players with default values
    const { playerId } = await client.playerThemes.create({});
    expect(playerId).to.be.a('string');

    // Get a player
    await client.playerThemes.get(playerId).then((player) => {
      expect(playerId).to.equals(player.playerId);
    });

    // Search a player with paginate results
    await client.playerThemes.list({ currentPage: 1, pageSize: 50 }).then(({ data: players}) => {
      expect(players).to.be.an('array');
      players.forEach(player => expect(player).to.have.keys(new Player()));
    });

    const properties: PlayerUpdatePayload = {
      // shapeMargin: 10,
      // shapeRadius: 3,
      // shapeAspect: 'flat',
      // shapeBackgroundTop: 'rgba(50, 50, 50, .7)',
      // shapeBackgroundBottom: 'rgba(50, 50, 50, .8)',
      // linkActive: 'rgba(255, 0, 0, .75)',
      text: 'rgba(255, 255, 255, .95)',
      link: 'rgba(255, 0, 0, .95)',
      linkHover: 'rgba(255, 255, 255, .75)',
      trackPlayed: 'rgba(255, 255, 255, .95)',
      trackUnplayed: 'rgba(255, 255, 255, .1)',
      trackBackground: 'rgba(0, 0, 0, 0)',
      backgroundTop: 'rgba(72, 4, 45, 1)',
      backgroundBottom: 'rgba(94, 95, 89, 1)',
      backgroundText: 'rgba(255, 255, 255, .95)',
      enableApi: true,
      enableControls: true,
      forceAutoplay: false,
      hideTitle: true,
      forceLoop: true,
    };

    await client.playerThemes.update(playerId, properties).then((player) => {
      Object.keys(properties).forEach((property) => {
        // expect(player).to.have.property(property, properties[property]);
      });
    });

    await client.playerThemes.uploadLogo(playerId,'test/data/test.jpg', 'https://api.video').then((player) => {
      expect(player.assets?.logo?.link).to.equals('https://api.video');
    });

    await client.playerThemes.delete(playerId).then((statusCode) => {
      expect(statusCode).to.equals(204);
    });

    // Create a live
    const name = 'This is a live';
    const { liveStreamId } = await client.liveStreams.create({ name });

    // Update live thumbnail
    await client.liveStreams.uploadThumbnail(liveStreamId, 'test/data/test.jpg').then((live) => {
      expect(live.name).to.equals(name);
    });

    // // Get live Analytics Data for the current year
    // await client.analyticsLive.get(liveStreamId, new Date().getFullYear()).then((analyticLive) => {
    //   expect(analyticLive.data).to.be.an('array');
    // });

    // Delete live resource
    await client.liveStreams.delete(liveStreamId).then((statusCode) => {
      expect(statusCode).to.equals(204);
    });

    // Create a private live
    const { liveStreamId: privateLiveStreamId, _public: isPublic } = await client.liveStreams.create({ name: 'This is a private live', _public: false });
    expect(isPublic).to.equals(false);

    // Delete the private live
    await client.liveStreams.delete(privateLiveStreamId).then((statusCode) => {
      expect(statusCode).to.equals(204);
    });

    // Generate a token for delegated upload
    await client.uploadTokens.createToken({}).then((token) => {
      expect(token).to.be.a('string');
    });
  } catch (e) {
    console.error(e);
    process.exit(1);
  }
})();
