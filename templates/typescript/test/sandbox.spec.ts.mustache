import { expect } from 'chai';
import ApiVideoClient from '../src';

{{#models}}
{{#model}}
import {{classFilename}} from '../{{ modelPackage }}/{{classFilename}}';
{{/model}}
{{/models}}

{{# apiInfo.apis }}
{{^x-client-hidden}}
import {{classFilename}} from '../{{ apiPackage }}/{{classFilename}}';
{{/x-client-hidden}}
{{/ apiInfo.apis }}

const timeout = (ms = 100) => new Promise((resolve) => {
  setTimeout(() => {
    resolve();
  }, ms);
});

(async () => {
  try {
    if (!process.env.API_KEY) {
      console.error(
        'You must provide `API_KEY` environment variable to test the sandbox.'
      );
      console.log('API_KEY=xxx yarn test:sandbox');

      process.exit(1);
    }

    // Create client for Sandbox and authenticate
    const client = new ApiVideoClient({ apiKey: process.env.API_KEY });

    // Create
    const videoTitle = 'Course #4 - Part B';
    const { videoId, title } = await client.videos.create({
      title: videoTitle,
    });

    // upload a video resource
    await client.videos
      .upload(videoId, 'test/data/small.webm')
      .then((video) => {
        expect(title).to.equals(videoTitle);
      });

    // Update video properties
    const newDescription = 'Course #4 - Part C';
    await client.videos
      .update(videoId, { description: newDescription })
      .then((video) => {
        expect(video.description).to.equals(newDescription);
      });

    // Search videos with paginated results
    await client.videos
      .list({ currentPage: 1, pageSize: 100 })
      .then(({ data: videos }) => {
        expect(videos).to.be.an('array');
        expect(
          videos.findIndex((v) => v.videoId === videoId) !== -1,
          'To find the previously created video in the list.'
        ).to.be.true;
      });

    // Upload a video thumbnail
    // @todo does not work yet
    // await client.videos.uploadThumbnail(videoId, 'test/data/test.jpg').then((video) => {
    //   expect(video.videoId).to.equals(videoId);
    // });

    // Pick a thumbnail from the given time code.
    await client.videos
      .pickThumbnail(videoId, { timecode: '00:15:22.05' })
      .then((video) => expect(video.videoId).to.equals(videoId));

    // Upload video caption
    await client.captions
      .upload(videoId, 'en', 'test/data/en.vtt')
      .then((caption) => expect(caption.srclang).to.equals('en'));

    await timeout(1000);

    // Get video caption by language
    await client.captions
      .get(videoId, 'en')
      .then((caption) => expect(caption.src).to.be.a('string'));

    // Update the default caption language
    await client.captions
      .update(videoId, 'en', { _default: true })
      .then((caption) => {
        expect(caption.srclang).to.equals('en');
        expect(caption._default).to.equals(true);
      });

    // Delete caption by language
    await client.captions.delete(videoId, 'en');

    // Upload video chapter
    await client.chapters
      .upload(videoId, 'en', 'test/data/en.vtt')
      .then((chapter) => expect(chapter.language).to.equals('en'));

    await timeout(1000);

    // Get video chapter by language
    await client.chapters
      .get(videoId, 'en')
      .then((chapter) => expect(chapter.language).to.equals('en'));

    // Delete chapter by language
    await client.chapters.delete(videoId, 'en');

    // Get video Analytics Data for the current year
    await client.rawStatistics
      .listVideoSessions({
        videoId,
        period: new Date().getFullYear().toString(),
      })
      .then(({ data: videoSessions }) => expect(videoSessions).to.be.an('array'));

    // Delete video resource
    await client.videos.delete(videoId);

    // Create a player theme with default values
    const { playerId } = await client.playerThemes.create();
    expect(playerId).to.be.a('string');

    // Get a playerTheme
    await client.playerThemes.get(playerId).then((playerTheme) => {
      expect(playerId).to.equals(playerTheme.playerId);
    });

    // Search a player theme with paginate results
    await client.playerThemes
      .list({ currentPage: 1, pageSize: 50 })
      .then(({ data: playerThemes }) => {
        expect(playerThemes).to.be.an('array');
        // @todo fix different keys
        // playerThemes.forEach(playerTheme => expect(playerTheme).to.have.keys(new PlayerTheme()));
      });

    const properties: PlayerThemeUpdatePayload = {
      text: 'rgba(255, 255, 255, .95)',
      link: 'rgba(255, 0, 0, .95)',
      linkHover: 'rgba(255, 255, 255, .75)',
      trackPlayed: 'rgba(255, 255, 255, .95)',
      trackUnplayed: 'rgba(255, 255, 255, .1)',
      trackBackground: 'rgba(0, 0, 0, 0)',
      backgroundTop: 'rgba(72, 4, 45, 1)',
      backgroundBottom: 'rgba(94, 95, 89, 1)',
      backgroundText: 'rgba(255, 255, 255, .95)',
      enableApi: true,
      enableControls: true,
      forceAutoplay: false,
      hideTitle: true,
      forceLoop: true,
    };

    await client.playerThemes
      .update(playerId, properties)
      .then((playerTheme) => {
        Object.keys(properties).forEach((property) => {
          // @ts-ignore
          expect(playerTheme).to.have.property(property, properties[property]);
        });
      });

    await client.playerThemes
      .uploadLogo(playerId, 'test/data/test.jpg', 'https://api.video')
      .then((playerTheme) =>
        expect(playerTheme.assets?.link).to.equals('https://api.video')
      );

    await client.playerThemes.delete(playerId);

    // Create a live
    const name = 'This is a live';
    const { liveStreamId, name: liveName } = await client.liveStreams.create({
      name,
    });
    expect(liveName).to.equals(name);

    // Update live thumbnail
    await client.liveStreams
      .uploadThumbnail(liveStreamId, 'test/data/test.jpg')
      .then((live) => expect(live.name).to.equals(name));

    // Get live Analytics Data for the current year
    await client.rawStatistics
      .listLiveStreamSessions({
        liveStreamId,
        period: new Date().getFullYear().toString(),
      })
      .then(({ data: liveStreamSessions }) =>
        expect(liveStreamSessions).to.be.an('array')
      );

    // Delete live resource
    await client.liveStreams.delete(liveStreamId);

    // Create a private live
    const {
      liveStreamId: privateLiveStreamId,
      _public: isPublic,
    } = await client.liveStreams.create({
      name: 'This is a private live',
      _public: false,
    });
    expect(isPublic).to.equals(false);

    // Delete the private live
    await client.liveStreams.delete(privateLiveStreamId);

    // Generate a token for delegated upload
    await client.uploadTokens
      .createToken()
      .then(({ token }) => expect(token).to.be.a('string'));
  } catch (e) {
    console.error(e);
    process.exit(1);
  }
})();
