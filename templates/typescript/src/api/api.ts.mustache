{{>licenseInfo}}

import path from 'path';
import { existsSync, statSync, createReadStream } from 'fs';
import { URLSearchParams } from 'url';
import FormData from 'form-data';
import ObjectSerializer from 'ObjectSerializer';
import HttpClient, { QueryOptions } from 'HttpClient';
{{#imports}}
import {{classname}} from 'model/{{classname}}';
{{/imports}}
{{#operations}}

/**
 * {{#description}}{{{description}}}{{/description}}{{^description}}no description{{/description}}
 */
export default class {{classname}} {
  private httpClient: HttpClient;

  constructor(httpClient: HttpClient) {
    this.httpClient = httpClient;
  }


  {{#operation}}
  {{#vendorExtensions.x-group-parameters}}
  /**
   {{#notes}}
   * {{&notes}}
   {{/notes}}
   {{#summary}}
   * {{&summary}}
   {{/summary}}
   * @param {Object} searchParams
   {{#allParams}}
   * @param { {{dataType}} } searchParams.{{paramName}} {{description}}
   {{/allParams}}
   */
  public async {{nickname}}({ {{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}} }: { {{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}{{^-last}}, {{/-last}}{{/allParams}} }): Promise<{{#returnType}}{{{returnType}}}{{/returnType}} {{^returnType}}void{{/returnType}}> {
    const queryParams: QueryOptions = {};
    queryParams.headers = {};
    {{#allParams}}
    {{#required}}
    // verify required parameter '{{paramName}}' is not null or undefined
    if ({{paramName}} === null || {{paramName}} === undefined) {
      throw new Error('Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
    }
    {{#isFile}}
    {{#platforms}}
    {{#node}}
    if (!existsSync({{paramName}})) {
      throw new Error(`${ {{paramName}} } must be a readable source file`);
    }

    const length = statSync({{paramName}}).size;
    if (length <= 0) {
      throw new Error(`${ {{paramName}} } is empty`);
    }
    {{/node}}
    {{/platforms}}
    {{/isFile}}
    {{/required}}
    {{/allParams}}
    // Path Params
    const localVarPath = '{{{path}}}'.substring(1){{#pathParams}}
      .replace('{' + '{{baseName}}' + '}', encodeURIComponent(String({{paramName}}))){{/pathParams}};
    {{#queryParams}}
    {{#-first}}

    // Query Params
    const urlSearchParams = new URLSearchParams();

    {{/-first}}
    if ({{paramName}} !== undefined) {
      urlSearchParams.append("{{baseName}}", ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}", "{{dataFormat}}"));
    }
    {{#-last}}

    queryParams.searchParams = urlSearchParams;
    {{/-last}}
    {{/queryParams}}
    {{#headerParams}}
    {{#-first}}

    // Header Params
    {{/-first}}
    queryParams.headers["{{baseName}}"] = ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}", "{{dataFormat}}");
    {{/headerParams}}

    {{#hasFormParams}}
    const formData = new FormData();
    {{/hasFormParams}}
    {{#formParams}}
    {{#isArray}}
    if ({{paramName}}) {
    {{#isCollectionFormatMulti}}
      {{paramName}}.forEach((element) => {
        formData.append('{{baseName}}', element);
      })
    {{/isCollectionFormatMulti}}
    {{^isCollectionFormatMulti}}
        formData.append('{{baseName}}', {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
    {{/isCollectionFormatMulti}}
    }
    {{/isArray}}
    {{^isArray}}
    if (typeof {{paramName}} !== undefined) {
      {{^isFile}}
      formData.append('{{baseName}}', {{paramName}});
      {{/isFile}}
      {{#isFile}}
      {{#platforms}}
      {{#node}}
      formData.append(
        filename,
        Buffer.isBuffer({{paramName}}) ? {{paramName}} : createReadStream({{paramName}}),
        filename,
      );
      {{/node}}
      {{^node}}
      formData.append('{{baseName}}', {{paramName}}, {{paramName}}.name);
      {{/node}}
      {{/platforms}}
      {{/isFile}}
    }
    {{/isArray}}
    {{/formParams}}
    {{#hasFormParams}}
    queryParams.body = formData;
    {{/hasFormParams}}
    {{#bodyParam}}

    // Body Params
    const contentType = ObjectSerializer.getPreferredMediaType([{{#consumes}}
      "{{{mediaType}}}"{{^-last}},{{/-last}}
    {{/consumes}}]);
    queryParams.headers["Content-Type"] = contentType;

    queryParams.body = ObjectSerializer.stringify(
      ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}", "{{dataFormat}}"),
      contentType
    );
    {{/bodyParam}}

    queryParams.method = '{{httpMethod}}';

    return this.httpClient.call(localVarPath, queryParams)
      .then(response => ObjectSerializer.deserialize(
        ObjectSerializer.parse(response.body, response.headers["content-type"]),
        "{{{returnType}}}", "{{returnFormat}}"
      ) as {{{returnType}}});
  }
  {{/vendorExtensions.x-group-parameters}}
  {{^vendorExtensions.x-group-parameters}}
  /**
   {{#notes}}
   * {{&notes}}
   {{/notes}}
   {{#summary}}
   * {{&summary}}
   {{/summary}}
   {{#allParams}}
   * @param {{paramName}} {{description}}
   {{/allParams}}
   */
  public async {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}{{#vendorExtensions.x-optional-object}} = {}{{/vendorExtensions.x-optional-object}}{{^-last}}, {{/-last}}{{/allParams}}): Promise<{{#returnType}}{{{returnType}}}{{/returnType}} {{^returnType}}void{{/returnType}}> {
    const queryParams: QueryOptions = {};
    queryParams.headers = {};
    {{#allParams}}

    {{#required}}
    // verify required parameter '{{paramName}}' is not null or undefined
    if ({{paramName}} === null || {{paramName}} === undefined) {
      throw new Error('Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
    }
    {{#isFile}}
    {{#platforms}}
    {{#node}}
    if (!existsSync({{paramName}})) {
      throw new Error(`${ {{paramName}} } must be a readable source file`);
    }

    const length = statSync({{paramName}}).size;
    if (length <= 0) {
      throw new Error(`${ {{paramName}} } is empty`);
    }
    {{/node}}
    {{/platforms}}
    {{/isFile}}
    {{/required}}
    {{/allParams}}
    // Path Params
    const localVarPath = '{{{path}}}'.substring(1){{#pathParams}}
      .replace('{' + '{{baseName}}' + '}', encodeURIComponent(String({{paramName}}))){{/pathParams}};
    {{#queryParams}}
    {{#-first}}

    // Query Params
    const urlSearchParams = new URLSearchParams();

    {{/-first}}
    if ({{paramName}} !== undefined) {
      urlSearchParams.append("{{baseName}}", ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}", "{{dataFormat}}"));
    }
    {{#-last}}

    queryParams.searchParams = urlSearchParams;
    {{/-last}}
    {{/queryParams}}
    {{#headerParams}}
    {{#-first}}

    // Header Params
    {{/-first}}
    queryParams.headers["{{baseName}}"] = ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}", "{{dataFormat}}");
    {{/headerParams}}

    {{#hasFormParams}}
    const formData = new FormData();
    {{/hasFormParams}}

    {{#formParams}}
    {{#isArray}}
    if ({{paramName}}) {
    {{#isCollectionFormatMulti}}
      {{paramName}}.forEach((element) => {
        formData.append('{{baseName}}', element);
      })
    {{/isCollectionFormatMulti}}
    {{^isCollectionFormatMulti}}
        formData.append('{{baseName}}', {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
    {{/isCollectionFormatMulti}}
    }
    {{/isArray}}
    {{^isArray}}
    if (typeof {{paramName}} !== undefined) {
      {{^isFile}}
      formData.append('{{baseName}}', {{paramName}});
      {{/isFile}}
      {{#isFile}}
      {{#platforms}}
      {{#node}}
      const filename = path.basename({{paramName}});
      formData.append(
        filename,
        Buffer.isBuffer({{paramName}}) ? {{paramName}} : createReadStream({{paramName}}),
        filename,
      );
      {{/node}}
      {{^node}}
      formData.append('{{baseName}}', {{paramName}}, {{paramName}}.name);
      {{/node}}
      {{/platforms}}
      {{/isFile}}
    }
    {{/isArray}}
    {{/formParams}}
    {{#hasFormParams}}
    queryParams.body = formData;
    {{/hasFormParams}}
    {{#bodyParam}}

    // Body Params
    const contentType = ObjectSerializer.getPreferredMediaType([{{#consumes}}
      "{{{mediaType}}}"{{^-last}},{{/-last}}
    {{/consumes}}]);
    queryParams.headers["Content-Type"] = contentType;

    queryParams.body = ObjectSerializer.stringify(
      ObjectSerializer.serialize({{paramName}}, "{{{dataType}}}", "{{dataFormat}}"),
      contentType
    );
    {{/bodyParam}}

    queryParams.method = '{{httpMethod}}';

    return this.httpClient.call(localVarPath, queryParams)
      .then(response => ObjectSerializer.deserialize(
        ObjectSerializer.parse(response.body, response.headers["content-type"]),
        "{{{returnType}}}", "{{returnFormat}}"
      ) as {{{returnType}}});
  }
  {{/vendorExtensions.x-group-parameters}}
  {{/operation}}

}
{{/operations}}
